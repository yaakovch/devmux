#!/usr/bin/env bash
# devmux — interactive SSH + tmux launcher.
# Connects to a remote host, picks a project, tool, and tmux mode.
set -euo pipefail

# ── Locate repo and source libraries ─────────────────────────────
resolve_path() {
    local path="$1"
    local resolved=""

    if command -v realpath >/dev/null 2>&1; then
        resolved=$(realpath "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    if command -v readlink >/dev/null 2>&1; then
        resolved=$(readlink -f "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    local target="$path"
    if command -v readlink >/dev/null 2>&1; then
        while [[ -L "$target" ]]; do
            local link
            link=$(readlink "$target")
            if [[ "$link" = /* ]]; then
                target="$link"
            else
                local dir
                dir=$(cd "$(dirname "$target")" && pwd -P)
                target="$dir/$link"
            fi
        done
    fi

    local dir
    dir=$(cd "$(dirname "$target")" && pwd -P)
    echo "$dir/$(basename "$target")"
}

SCRIPT_PATH="$(resolve_path "$0")"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd -P)"

# ── Optional self-update (git pull) ───────────────────────────────
_devmux_self_update() {
    local repo_dir="$1"
    local script_path="$2"
    shift 2
    local -a argv=("$@")

    local updated=false
    local old_head="" new_head=""

    # Used if flock(1) is available (preferred).
    local lock_fd_open=false

    # Used if flock(1) is NOT available (mkdir-based lock).
    local lock_dir_path=""
    local state_dir=""

    while true; do
        # Only attempt once per process to avoid update loops.
        if [[ -n "${DEVMUX_SELF_UPDATED:-}" ]]; then
            break
        fi

        case "${DEVMUX_AUTO_UPDATE:-1}" in
            0|false|no|off) break ;;
        esac

        command -v git >/dev/null 2>&1 || break
        git -C "$repo_dir" rev-parse --git-dir >/dev/null 2>&1 || break

        # Cache/lock dir: prefer XDG cache; fall back to /tmp if not writable.
        local try_dir=""
        try_dir="${XDG_CACHE_HOME:-$HOME/.cache}/devmux"
        if mkdir -p "$try_dir" 2>/dev/null; then
            state_dir="$try_dir"
        else
            try_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
            mkdir -p "$try_dir" 2>/dev/null || break
            state_dir="$try_dir"
        fi

        # Best-effort lock: skip update if another devmux is updating.
        if command -v flock >/dev/null 2>&1; then
            if ! { exec 9>"$state_dir/update.lock"; } 2>/dev/null; then
                local tmp_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
                mkdir -p "$tmp_dir" 2>/dev/null || break
                state_dir="$tmp_dir"
                { exec 9>"$state_dir/update.lock"; } 2>/dev/null || break
            fi
            if ! flock -n 9; then
                exec 9>&- 2>/dev/null || true
                break
            fi
            lock_fd_open=true
        else
            lock_dir_path="$state_dir/update.lock.d"
            if ! mkdir "$lock_dir_path" 2>/dev/null; then
                if [[ -d "$lock_dir_path" ]]; then
                    break
                fi
                local tmp_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
                mkdir -p "$tmp_dir" 2>/dev/null || break
                state_dir="$tmp_dir"
                lock_dir_path="$state_dir/update.lock.d"
                mkdir "$lock_dir_path" 2>/dev/null || break
            fi
        fi

        # Optional interval between update attempts (0 = every run).
        local interval="${DEVMUX_UPDATE_INTERVAL_SECS:-0}"
        if [[ "$interval" =~ ^[0-9]+$ ]] && (( interval > 0 )); then
            local stamp="$state_dir/last_update"

            local now last=0
            now="$(date +%s 2>/dev/null || echo 0)"
            last="$(cat "$stamp" 2>/dev/null || echo 0)"

            if [[ "$now" =~ ^[0-9]+$ && "$last" =~ ^[0-9]+$ ]] && (( now - last < interval )); then
                break
            fi

            printf '%s' "$now" >"$stamp" 2>/dev/null || true
        fi

        old_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null || true)"

        local dirty=false
        if ! git -C "$repo_dir" diff --quiet --ignore-submodules -- 2>/dev/null; then
            dirty=true
        elif ! git -C "$repo_dir" diff --cached --quiet --ignore-submodules -- 2>/dev/null; then
            dirty=true
        elif [[ -n "$(git -C "$repo_dir" ls-files --others --exclude-standard 2>/dev/null)" ]]; then
            dirty=true
        fi

        local stash_mode="${DEVMUX_UPDATE_STASH:-}"
        if [[ -z "$stash_mode" ]]; then
            if command -v termux-info >/dev/null 2>&1 || [[ "${PREFIX:-}" == "/data/data/com.termux/files/usr"* ]]; then
                stash_mode=1
            else
                stash_mode=0
            fi
        fi

        if $dirty; then
            case "$stash_mode" in
                1|true|yes|on)
                    echo "devmux: repo dirty; stashing local changes before update..." >&2
                    local ts msg
                    ts="$(date +%Y%m%d-%H%M%S 2>/dev/null || date)"
                    msg="devmux-auto-stash $ts"
                    GIT_TERMINAL_PROMPT=0 GCM_INTERACTIVE=Never \
                        git -C "$repo_dir" stash push -u -m "$msg" >/dev/null 2>&1 || true
                    ;;
                *)
                    echo "devmux: repo dirty; skipping auto-update (set DEVMUX_UPDATE_STASH=1 to auto-stash)" >&2
                    break
                    ;;
            esac
        fi

        local ssh_cmd="${GIT_SSH_COMMAND:-ssh -o BatchMode=yes -o ConnectTimeout=5}"
        if GIT_TERMINAL_PROMPT=0 GCM_INTERACTIVE=Never GIT_SSH_COMMAND="$ssh_cmd" \
            git -C "$repo_dir" pull --ff-only >/dev/null 2>&1; then
            updated=true
        fi

        new_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null || true)"
        break
    done

    if $lock_fd_open; then
        exec 9>&- 2>/dev/null || true
    fi
    if [[ -n "$lock_dir_path" ]]; then
        rmdir "$lock_dir_path" 2>/dev/null || true
    fi

    if $updated && [[ -n "$old_head" && -n "$new_head" && "$old_head" != "$new_head" ]]; then
        echo "devmux: updated, restarting..." >&2
        export DEVMUX_SELF_UPDATED=1
        exec "$script_path" "${argv[@]}"
    fi

    return 0
}

_devmux_self_update "$REPO_DIR" "$SCRIPT_PATH" "$@"

if [[ -d "$REPO_DIR/lib" ]]; then
    source "$REPO_DIR/lib/common.sh"
else
    # Fallback if running outside repo (shouldn't happen with symlink install)
    die() { echo "Error: $*" >&2; exit 1; }
    die "Cannot find lib/ directory. Is the devmux repo intact?"
fi

# ── Config ─────────────────────────────────────────────────────────
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/devmux"
CONFIG_FILE="$CONFIG_DIR/devmux.conf"
REMOTE_SCRIPT="${REMOTE_SCRIPT:-devmux-remote}"
SSH_OPTS="${SSH_OPTS:-}"

# ── Local host detection (avoid SSH-to-self) ─────────────────────
detect_self_tailscale_ip() {
    local repo_dir="$1"
    local self_name="" self_ts_ip=""

    if [[ -f "$repo_dir/lib/platform.sh" && -f "$repo_dir/machines.conf" ]]; then
        # shellcheck source=/dev/null
        source "$repo_dir/lib/platform.sh"
        # shellcheck source=/dev/null
        source "$repo_dir/machines.conf"

        self_name="$(detect_hostname)"
        if declare -p MACHINES >/dev/null 2>&1; then
            local machine var_prefix ts_ip_var
            for machine in "${MACHINES[@]}"; do
                if [[ "$machine" == "$self_name" ]]; then
                    var_prefix="MACHINE_${machine//-/_}"
                    ts_ip_var="${var_prefix}_TAILSCALE_IP"
                    self_ts_ip="${!ts_ip_var:-}"
                    break
                fi
            done
        fi
    fi

    echo "$self_ts_ip"
}

ssh_config_hostname() {
    local target="$1"
    local line
    while IFS= read -r line; do
        case "$line" in
            hostname\ *) echo "${line#hostname }"; return 0 ;;
        esac
    done < <(ssh -G "$target" 2>/dev/null || true)
    return 1
}

should_run_local() {
    local ssh_target="$1"
    local self_ts_ip="$2"

    case "$ssh_target" in
        ""|local|localhost|127.0.0.1|::1) return 0 ;;
    esac

    if [[ -n "$self_ts_ip" ]]; then
        local host_name
        host_name="$(ssh_config_hostname "$ssh_target" || true)"
        if [[ -n "$host_name" && "$host_name" == "$self_ts_ip" ]]; then
            return 0
        fi
    fi

    return 1
}

local_remote_script() {
    local remote_script="$1"
    local repo_dir="$2"

    if command -v "$remote_script" >/dev/null 2>&1; then
        echo "$remote_script"
        return 0
    fi
    if [[ -x "$repo_dir/scripts/devmux-remote" ]]; then
        echo "$repo_dir/scripts/devmux-remote"
        return 0
    fi

    return 1
}

# ── Defaults (overridden by config) ───────────────────────────────
HOSTS=()
TOOLS=("shell")
TOOL_shell_CMD=""

# ── Usage ──────────────────────────────────────────────────────────
usage() {
    cat <<'EOF'
Usage: devmux [OPTIONS]

Interactive menu to SSH into a host, pick a project, tool, and tmux session.

Options:
  --host <name>       Skip host picker
  --project <name>    Skip project picker
  --tool <name>       Skip tool picker
  --mode <resume|new> Skip mode picker
  -h, --help          Show this help

Config: ~/.config/devmux/devmux.conf
EOF
}

# ── Early --help check (before config) ────────────────────────────
for arg in "$@"; do
    case "$arg" in
        -h|--help) usage; exit 0 ;;
    esac
done

# ── Load config ───────────────────────────────────────────────────
if [[ ! -f "$CONFIG_FILE" ]]; then
    die "Config not found: $CONFIG_FILE
Run setup.sh or copy config/devmux.example.conf there."
fi

# shellcheck source=/dev/null
source "$CONFIG_FILE"

# ── Parse CLI overrides ───────────────────────────────────────────
ARG_HOST="" ARG_PROJECT="" ARG_TOOL="" ARG_MODE=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        --host)    ARG_HOST="$2"; shift 2 ;;
        --project) ARG_PROJECT="$2"; shift 2 ;;
        --tool)    ARG_TOOL="$2"; shift 2 ;;
        --mode)    ARG_MODE="$2"; shift 2 ;;
        -h|--help) usage; exit 0 ;;
        *)         die "Unknown option: $1" ;;
    esac
done

# ── Step 1: Choose host ───────────────────────────────────────────
if [[ ${#HOSTS[@]} -eq 0 ]]; then
    die "No HOSTS defined in config."
fi

if [[ -n "$ARG_HOST" ]]; then
    HOST="$ARG_HOST"
else
    HOST=$(pick "Host:" "${HOSTS[@]}")
fi

SSH_TARGET=$(get_var "HOST_${HOST//-/_}_SSH")
WSL_PREFIX=$(get_var "HOST_${HOST//-/_}_WSL_PREFIX")
PROJECTS_DIR=$(get_var "HOST_${HOST//-/_}_PROJECTS_DIR")
PROJECTS_DIR="${PROJECTS_DIR:-\$HOME/projects}"

if [[ -z "$SSH_TARGET" ]]; then
    die "HOST_${HOST//-/_}_SSH not set in config."
fi

# If the chosen host resolves to this machine, run locally to avoid SSH-to-self.
SELF_TS_IP="$(detect_self_tailscale_ip "$REPO_DIR")"
LOCAL_MODE=false
if should_run_local "$SSH_TARGET" "$SELF_TS_IP"; then
    LOCAL_MODE=true
fi

# ── Step 2: Fetch remote project list ─────────────────────────────
REMOTE_LS_CMD="ls -1 ${PROJECTS_DIR} 2>/dev/null || true"
if $LOCAL_MODE; then
    PROJECT_LIST=""
    PROJECT_LIST=$(spin "Loading projects (local)..." bash -lc "$REMOTE_LS_CMD" 2>/dev/null) || \
        die "Could not list projects locally. Check that your projects directory exists."
else
    if [[ -n "$WSL_PREFIX" ]]; then
        remote_ls_escaped="${REMOTE_LS_CMD//\"/\\\"}"
        REMOTE_CMD="$WSL_PREFIX \"${remote_ls_escaped}\""
    else
        REMOTE_CMD="$REMOTE_LS_CMD"
    fi

    PROJECT_LIST=""
    # shellcheck disable=SC2086
    PROJECT_LIST=$(spin "Connecting to $HOST ($SSH_TARGET)..." \
        ssh $SSH_OPTS -o ConnectTimeout=10 "$SSH_TARGET" "$REMOTE_CMD" 2>/dev/null) || \
        die "Could not connect to $SSH_TARGET. Check SSH config and connectivity."
fi

if [[ -z "$PROJECT_LIST" ]]; then
    die "No projects found on $HOST under $PROJECTS_DIR."
fi

mapfile -t PROJECTS <<< "$PROJECT_LIST"

if [[ -n "$ARG_PROJECT" ]]; then
    PROJECT="$ARG_PROJECT"
else
    PROJECT=$(pick "Project:" "${PROJECTS[@]}")
fi

# ── Step 3: Choose tool ──────────────────────────────────────────
if [[ ${#TOOLS[@]} -eq 0 ]]; then
    die "No TOOLS defined in config."
fi

if [[ -n "$ARG_TOOL" ]]; then
    TOOL="$ARG_TOOL"
else
    TOOL=$(pick "Tool:" "${TOOLS[@]}")
fi

TOOL_CMD=$(get_var "TOOL_${TOOL}_CMD")

# ── Step 4: Choose mode ──────────────────────────────────────────
if [[ -n "$ARG_MODE" ]]; then
    MODE="$ARG_MODE"
else
    MODE=$(pick "Mode:" "resume" "new")
fi

# ── Step 5: Connect ──────────────────────────────────────────────
REMOTE_ARGV=(--project "$PROJECT" --tool "$TOOL" --mode "$MODE")
if [[ -n "$TOOL_CMD" ]]; then
    REMOTE_ARGV+=(--tool-cmd "$TOOL_CMD")
fi

REMOTE_ARGS_Q=""
for arg in "${REMOTE_ARGV[@]}"; do
    REMOTE_ARGS_Q+=" $(printf '%q' "$arg")"
done
REMOTE_EXEC="$REMOTE_SCRIPT$REMOTE_ARGS_Q"
if $LOCAL_MODE; then
    LOCAL_REMOTE_SCRIPT="$(local_remote_script "$REMOTE_SCRIPT" "$REPO_DIR")" || \
        die "Local run requested but devmux-remote not found. Run setup.sh on this host."
else
    if [[ -n "$WSL_PREFIX" ]]; then
        # Windows uses cmd-style quoting; wrap the bash command in double quotes.
        remote_exec_escaped="${REMOTE_EXEC//\"/\\\"}"
        FULL_CMD="$WSL_PREFIX \"${remote_exec_escaped}\""
    else
        FULL_CMD="$REMOTE_EXEC"
    fi
fi

header "→ $HOST / $PROJECT / $TOOL ($MODE)"
if $LOCAL_MODE; then
    exec "$LOCAL_REMOTE_SCRIPT" "${REMOTE_ARGV[@]}"
else
    # shellcheck disable=SC2086
    exec ssh $SSH_OPTS -t "$SSH_TARGET" "$FULL_CMD"
fi
