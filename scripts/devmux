#!/usr/bin/env bash
# devmux — interactive SSH + tmux launcher.
# Connects to a remote host, picks a project, and manages tmux sessions.
set -euo pipefail

# ── Locate repo and source libraries ─────────────────────────────
resolve_path() {
    local path="$1"
    local resolved=""

    if command -v realpath >/dev/null 2>&1; then
        resolved=$(realpath "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    if command -v readlink >/dev/null 2>&1; then
        resolved=$(readlink -f "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    local target="$path"
    if command -v readlink >/dev/null 2>&1; then
        while [[ -L "$target" ]]; do
            local link
            link=$(readlink "$target")
            if [[ "$link" = /* ]]; then
                target="$link"
            else
                local dir
                dir=$(cd "$(dirname "$target")" && pwd -P)
                target="$dir/$link"
            fi
        done
    fi

    local dir
    dir=$(cd "$(dirname "$target")" && pwd -P)
    echo "$dir/$(basename "$target")"
}

SCRIPT_PATH="$(resolve_path "$0")"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd -P)"

# ── Optional self-update ──────────────────────────────────────────
# Entire update runs inside `timeout … bash -c` so it can NEVER hang
# or block startup, regardless of network, git state, or filesystem.
_devmux_update_result=""
if [[ -z "${DEVMUX_SELF_UPDATED:-}" ]]; then
    case "${DEVMUX_AUTO_UPDATE:-1}" in
        0|false|no|off) ;;
        *)
            _devmux_old_head="$(git -C "$REPO_DIR" rev-parse HEAD 2>/dev/null || true)"
            if [[ -n "$_devmux_old_head" ]]; then
                timeout "${DEVMUX_UPDATE_TIMEOUT_SECS:-10}" bash -c '
                    repo="$1"
                    state="${XDG_CACHE_HOME:-$HOME/.cache}/devmux"
                    mkdir -p "$state" 2>/dev/null || exit 0
                    lock="$state/update.lock.d"
                    mkdir "$lock" 2>/dev/null || exit 0
                    trap "rmdir \"$lock\" 2>/dev/null" EXIT
                    branch=$(git -C "$repo" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null \
                        | sed "s|refs/remotes/origin/||") || true
                    : "${branch:=main}"
                    GIT_TERMINAL_PROMPT=0 GCM_INTERACTIVE=Never \
                        GIT_SSH_COMMAND="${GIT_SSH_COMMAND:-ssh -o BatchMode=yes -o ConnectTimeout=5}" \
                        git -C "$repo" fetch --quiet origin "$branch" 2>/dev/null || exit 0
                    git -C "$repo" reset --hard "origin/$branch" >/dev/null 2>&1
                ' _ "$REPO_DIR" 2>/dev/null || true
                _devmux_new_head="$(git -C "$REPO_DIR" rev-parse HEAD 2>/dev/null || true)"
                if [[ -n "$_devmux_new_head" && "$_devmux_old_head" != "$_devmux_new_head" ]]; then
                    _devmux_update_result=1
                fi
            fi
            ;;
    esac
fi

if [[ -n "$_devmux_update_result" ]]; then
    echo "devmux: updated, restarting..." >&2
    export DEVMUX_SELF_UPDATED=1
    exec "$SCRIPT_PATH" "$@"
fi

if [[ -d "$REPO_DIR/lib" ]]; then
    source "$REPO_DIR/lib/common.sh"
else
    # Fallback if running outside repo (shouldn't happen with symlink install)
    die() { echo "Error: $*" >&2; exit 1; }
    die "Cannot find lib/ directory. Is the devmux repo intact?"
fi

# ── Config ─────────────────────────────────────────────────────────
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/devmux"
CONFIG_FILE="$CONFIG_DIR/devmux.conf"
REMOTE_SCRIPT="${REMOTE_SCRIPT:-devmux-remote}"
SSH_OPTS="${SSH_OPTS:-}"

# ── Local host detection (avoid SSH-to-self) ─────────────────────
detect_self_tailscale_ip() {
    local repo_dir="$1"
    local self_name="" self_ts_ip=""

    if [[ -f "$repo_dir/lib/platform.sh" && -f "$repo_dir/machines.conf" ]]; then
        # shellcheck source=/dev/null
        source "$repo_dir/lib/platform.sh"
        # shellcheck source=/dev/null
        source "$repo_dir/machines.conf"

        self_name="$(detect_hostname)"
        if declare -p MACHINES >/dev/null 2>&1; then
            local machine var_prefix ts_ip_var
            for machine in "${MACHINES[@]}"; do
                if [[ "$machine" == "$self_name" ]]; then
                    var_prefix="MACHINE_${machine//-/_}"
                    ts_ip_var="${var_prefix}_TAILSCALE_IP"
                    self_ts_ip="${!ts_ip_var:-}"
                    break
                fi
            done
        fi
    fi

    echo "$self_ts_ip"
}

ssh_config_hostname() {
    local target="$1"
    local line
    while IFS= read -r line; do
        case "$line" in
            hostname\ *) echo "${line#hostname }"; return 0 ;;
        esac
    done < <(ssh -G "$target" 2>/dev/null || true)
    return 1
}

should_run_local() {
    local ssh_target="$1"
    local self_ts_ip="$2"

    case "$ssh_target" in
        ""|local|localhost|127.0.0.1|::1) return 0 ;;
    esac

    if [[ -n "$self_ts_ip" ]]; then
        local host_name
        host_name="$(ssh_config_hostname "$ssh_target" || true)"
        if [[ -n "$host_name" && "$host_name" == "$self_ts_ip" ]]; then
            return 0
        fi
    fi

    return 1
}

local_remote_script() {
    local remote_script="$1"
    local repo_dir="$2"

    if command -v "$remote_script" >/dev/null 2>&1; then
        echo "$remote_script"
        return 0
    fi
    if [[ -x "$repo_dir/scripts/devmux-remote" ]]; then
        echo "$repo_dir/scripts/devmux-remote"
        return 0
    fi

    return 1
}

# ── SSH with retry ─────────────────────────────────────────────────
ssh_with_retry() {
    local max_retries=2
    local delay=3
    local attempt=0
    local exit_code=0
    
    while [[ $attempt -le $max_retries ]]; do
        if [[ $attempt -gt 0 ]]; then
            echo "  Retry $attempt/$max_retries in ${delay}s..." >&2
            sleep $delay
        fi
        
        # shellcheck disable=SC2086
        ssh $SSH_OPTS "$@"
        exit_code=$?
        
        if [[ $exit_code -eq 0 ]]; then
            return 0
        fi
        
        ((attempt++))
    done
    
    return $exit_code
}

# ── Pre-flight connectivity check ──────────────────────────────────
preflight_check() {
    local ssh_target="$1"
    
    # Skip if --fast flag was used
    if $SKIP_PREFLIGHT; then
        return 0
    fi
    
    # Quick connectivity test (3 second timeout)
    if ! ssh $SSH_OPTS -o ConnectTimeout=3 -o BatchMode=yes "$ssh_target" exit 2>/dev/null; then
        # Check if we're using Tailscale SSH (ProxyCommand) for a better error message
        local hint="  The host may be offline or SSH keys not configured."
        if ssh -G "$ssh_target" 2>/dev/null | grep -qi "proxycommand.*tailscale"; then
            hint="  Tailscale SSH is configured. Check:
    1. Is Tailscale running? (tailscale status / tailscale.exe status)
    2. Is the host online in your Tailnet?
    3. Is Tailscale SSH enabled on the host? (tailscale up --ssh)"
        fi
        die "Pre-flight check failed: Cannot connect to $HOST ($ssh_target)
$hint
  Use --fast to skip this check."
    fi
    
    return 0
}

# ── Config validation ──────────────────────────────────────────────
validate_config() {
    local errors=0
    
    # Check that HOSTS array is defined and not empty
    if [[ ${#HOSTS[@]} -eq 0 ]]; then
        echo "Warning: No HOSTS defined in config." >&2
        ((errors++))
    fi
    
    # Check that each host has required variables
    for host in "${HOSTS[@]}"; do
        local ssh_var="HOST_${host//-/_}_SSH"
        if [[ -z "${!ssh_var:-}" ]]; then
            echo "Error: HOST_${host//-/_}_SSH is not set for host '$host'" >&2
            ((errors++))
        fi
    done
    
    if [[ $errors -gt 0 ]]; then
        echo "Config validation failed with $errors error(s)." >&2
        echo "Please check your config at ~/.config/devmux/devmux.conf" >&2
        return 1
    fi
    
    return 0
}

# ── Debug mode ────────────────────────────────────────────────────
DEBUG_MODE="${DEVMUX_DEBUG:-false}"
debug() {
    if [[ "$DEBUG_MODE" == "true" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

# ── Defaults (overridden by config) ───────────────────────────────
HOSTS=()

# ── Usage ──────────────────────────────────────────────────────────
usage() {
    cat <<'EOF'
Usage: devmux [OPTIONS]

Interactive menu to SSH into a host, pick a project, and manage tmux sessions.

Options:
  --host <name>         Skip host picker
  --project <name>      Skip project picker
  --session <name|new>  Attach to a session by name, or "new" to create one
  --settings            Open settings menu
  --fast                Skip pre-flight connectivity check
  -h, --help            Show this help

Subcommands:
  settings              Open settings menu (same as --settings)

Config: ~/.config/devmux/devmux.conf
EOF
}

# ── Early --help check (before config) ────────────────────────────
for arg in "$@"; do
    case "$arg" in
        -h|--help) usage; exit 0 ;;
    esac
done

# ── Load config ───────────────────────────────────────────────────
if [[ ! -f "$CONFIG_FILE" ]]; then
    die "Config not found: $CONFIG_FILE
Run setup.sh or copy config/devmux.example.conf there."
fi

# shellcheck source=/dev/null
source "$CONFIG_FILE"

# Validate config
validate_config || exit 1

# ── Parse CLI overrides ───────────────────────────────────────────
ARG_HOST="" ARG_PROJECT="" ARG_SESSION="" ARG_SETTINGS=false SKIP_PREFLIGHT=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        --host)     ARG_HOST="$2"; shift 2 ;;
        --project)  ARG_PROJECT="$2"; shift 2 ;;
        --session)  ARG_SESSION="$2"; shift 2 ;;
        --settings) ARG_SETTINGS=true; shift ;;
        --fast)     SKIP_PREFLIGHT=true; shift ;;
        settings)   ARG_SETTINGS=true; shift ;;
        -h|--help)  usage; exit 0 ;;
        *)          die "Unknown option: $1" ;;
    esac
done

# ── Handle settings early ────────────────────────────────────────
if $ARG_SETTINGS; then
    source "$REPO_DIR/scripts/devmux-settings"
    settings_menu
    exit 0
fi

# ── Step 1: Choose host ───────────────────────────────────────────
if [[ ${#HOSTS[@]} -eq 0 ]]; then
    die "No HOSTS defined in config."
fi

if [[ -n "$ARG_HOST" ]]; then
    HOST="$ARG_HOST"
else
    HOST=$(pick "Host:" "${HOSTS[@]}" "--- Settings ---")
    if [[ "$HOST" == "--- Settings ---" ]]; then
        source "$REPO_DIR/scripts/devmux-settings"
        settings_menu
        exec "$SCRIPT_PATH"
    fi
fi

SSH_TARGET=$(get_var "HOST_${HOST//-/_}_SSH")
WSL_PREFIX=$(get_var "HOST_${HOST//-/_}_WSL_PREFIX")
PROJECTS_DIR=$(get_var "HOST_${HOST//-/_}_PROJECTS_DIR")
PROJECTS_DIR="${PROJECTS_DIR:-\$HOME/projects}"

if [[ -z "$SSH_TARGET" ]]; then
    die "HOST_${HOST//-/_}_SSH not set in config."
fi

# If the chosen host resolves to this machine, run locally to avoid SSH-to-self.
SELF_TS_IP="$(detect_self_tailscale_ip "$REPO_DIR")"
LOCAL_MODE=false
if should_run_local "$SSH_TARGET" "$SELF_TS_IP"; then
    LOCAL_MODE=true
fi

debug "Host: $HOST"
debug "SSH Target: $SSH_TARGET"
debug "Local Mode: $LOCAL_MODE"
debug "Projects Dir: $PROJECTS_DIR"

# ── Pre-flight connectivity check (skipped in local mode) ─────────
if ! $LOCAL_MODE; then
    preflight_check "$SSH_TARGET"
fi

# ── Step 2: Fetch remote project list ─────────────────────────────
REMOTE_LS_CMD="ls -1 ${PROJECTS_DIR} 2>/dev/null || true"
if $LOCAL_MODE; then
    PROJECT_LIST=""
    PROJECT_LIST=$(spin "Loading projects (local)..." bash -lc "$REMOTE_LS_CMD" 2>/dev/null) || \
        die "Failed to list projects in local directory: $PROJECTS_DIR
  Check that the directory exists and is readable."

else
    if [[ -n "$WSL_PREFIX" ]]; then
        # Use base64 encoding to safely pass the command through WSL.
        # Double quotes are critical: Windows CMD ignores single quotes and
        # splits on unquoted pipes, breaking the entire command.
        remote_ls_b64=$(echo "$REMOTE_LS_CMD" | base64 -w0)
        REMOTE_CMD="$WSL_PREFIX bash -lc \"echo $remote_ls_b64 | base64 -d | bash\""
    else
        REMOTE_CMD="$REMOTE_LS_CMD"
    fi

    PROJECT_LIST=""
    # shellcheck disable=SC2086
    PROJECT_LIST=$(spin "Connecting to $HOST ($SSH_TARGET)..." \
        ssh_with_retry -o ConnectTimeout=10 "$SSH_TARGET" "$REMOTE_CMD" 2>/dev/null) || \
        die "SSH connection failed to $HOST ($SSH_TARGET) after 3 attempts
  Troubleshooting:
    1. Verify the host is online: ping $SSH_TARGET
    2. Check SSH config: ssh -G $HOST | grep hostname
    3. Test manually: ssh -v $SSH_TARGET echo 'OK'
    4. Verify SSH key is authorized on the remote host"
fi

if [[ -z "$PROJECT_LIST" ]]; then
    warn "No projects found on $HOST in $PROJECTS_DIR"
    
    if $LOCAL_MODE; then
        if confirm "Create a sample project?"; then
            mkdir -p "$HOME/projects/my-project"
            echo "# My Project" > "$HOME/projects/my-project/README.md"
            ok "Created $HOME/projects/my-project with README.md"
            PROJECT_LIST="my-project"
        else
            die "Cannot continue without projects. Create one manually or update config."
        fi
    else
        if confirm "Create a sample project on $HOST?"; then
            # Create project on remote host
            ssh $SSH_OPTS "$SSH_TARGET" "mkdir -p $PROJECTS_DIR/my-project && echo '# My Project' > $PROJECTS_DIR/my-project/README.md"
            ok "Created sample project 'my-project' on $HOST"
            PROJECT_LIST="my-project"
        else
            die "Cannot continue without projects. Create one manually or update config."
        fi
    fi
fi

mapfile -t PROJECTS <<< "$PROJECT_LIST"

if [[ -n "$ARG_PROJECT" ]]; then
    PROJECT="$ARG_PROJECT"
else
    PROJECT=$(pick "Project:" "${PROJECTS[@]}")
fi

debug "Project: $PROJECT"

# ── Step 3: Connect ──────────────────────────────────────────────
REMOTE_ARGV=(--project "$PROJECT")
if [[ -n "$ARG_SESSION" ]]; then
    REMOTE_ARGV+=(--session "$ARG_SESSION")
fi

REMOTE_ARGS_Q=""
for arg in "${REMOTE_ARGV[@]}"; do
    REMOTE_ARGS_Q+=" $(printf '%q' "$arg")"
done
REMOTE_EXEC="$REMOTE_SCRIPT$REMOTE_ARGS_Q"

debug "Remote exec: $REMOTE_EXEC"

if $LOCAL_MODE; then
    LOCAL_REMOTE_SCRIPT="$(local_remote_script "$REMOTE_SCRIPT" "$REPO_DIR")" || \
        die "Local run requested but devmux-remote not found. Run setup.sh on this host."
else
    if [[ -n "$WSL_PREFIX" ]]; then
        # Double quotes protect special chars from Windows CMD interpretation.
        # Use process substitution <() so bash reads the script from a fd,
        # keeping stdin free for interactive input (e.g. session picker).
        remote_exec_b64=$(echo "$REMOTE_EXEC" | base64 -w0)
        FULL_CMD="$WSL_PREFIX bash -lc \"bash <(echo $remote_exec_b64 | base64 -d)\""
    else
        FULL_CMD="$REMOTE_EXEC"
    fi
fi

header "→ $HOST / $PROJECT"
if $LOCAL_MODE; then
    exec "$LOCAL_REMOTE_SCRIPT" "${REMOTE_ARGV[@]}"
else
    debug "Full command: $FULL_CMD"
    # shellcheck disable=SC2086
    exec ssh $SSH_OPTS -t "$SSH_TARGET" "$FULL_CMD"
fi
