#!/usr/bin/env bash
# devmux-remote — runs on the host inside WSL/Linux.
# Manages tmux sessions for a given project.
set -euo pipefail

# ── Debug mode ─────────────────────────────────────────────────────
DEBUG_MODE="${DEVMUX_DEBUG:-false}"
debug() {
    if [[ "$DEBUG_MODE" == "true" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

# ── Locate repo (for optional self-update) ──────────────────────────
resolve_path() {
    local path="$1"
    local resolved=""

    if command -v realpath >/dev/null 2>&1; then
        resolved=$(realpath "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    if command -v readlink >/dev/null 2>&1; then
        resolved=$(readlink -f "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    local target="$path"
    if command -v readlink >/dev/null 2>&1; then
        while [[ -L "$target" ]]; do
            local link
            link=$(readlink "$target")
            if [[ "$link" = /* ]]; then
                target="$link"
            else
                local dir
                dir=$(cd "$(dirname "$target")" && pwd -P)
                target="$dir/$link"
            fi
        done
    fi

    local dir
    dir=$(cd "$(dirname "$target")" && pwd -P)
    echo "$dir/$(basename "$target")"
}

SCRIPT_PATH="$(resolve_path "$0")"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd -P)"

# ── Source common library ─────────────────────────────────────────
if [[ -f "$REPO_DIR/lib/common.sh" ]]; then
    source "$REPO_DIR/lib/common.sh"
else
    # Minimal fallbacks if running outside repo
    die() { echo "Error: $*" >&2; exit 1; }
    pick() {
        local prompt="$1"; shift
        local items=("$@")
        echo "$prompt" >&2
        local i
        for i in "${!items[@]}"; do
            echo "  $((i+1))) ${items[$i]}" >&2
        done
        while true; do
            read -rp "#? " choice
            if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#items[@]} )); then
                echo "${items[$((choice-1))]}"
                return
            fi
            echo "Invalid choice. Enter 1-${#items[@]}." >&2
        done
    }
fi

# ── Optional self-update (git pull) ───────────────────────────────
_devmux_remote_self_update() {
    local repo_dir="$1"
    local script_path="$2"
    shift 2
    local -a argv=("$@")

    local updated=false
    local old_head="" new_head=""

    # Used if flock(1) is available (preferred).
    local lock_fd_open=false

    # Used if flock(1) is NOT available (mkdir-based lock).
    local lock_dir_path=""
    local state_dir=""

    while true; do
        # Only attempt once per process to avoid update loops.
        if [[ -n "${DEVMUX_REMOTE_SELF_UPDATED:-}" ]]; then
            break
        fi

        local auto="${DEVMUX_REMOTE_AUTO_UPDATE:-${DEVMUX_AUTO_UPDATE:-1}}"
        case "$auto" in
            0|false|no|off) break ;;
        esac

        command -v git >/dev/null 2>&1 || break
        git -C "$repo_dir" rev-parse --git-dir >/dev/null 2>&1 || break

        # Cache/lock dir: prefer XDG cache; fall back to /tmp if not writable.
        local try_dir=""
        try_dir="${XDG_CACHE_HOME:-$HOME/.cache}/devmux"
        if mkdir -p "$try_dir" 2>/dev/null; then
            state_dir="$try_dir"
        else
            try_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
            mkdir -p "$try_dir" 2>/dev/null || break
            state_dir="$try_dir"
        fi

        # Best-effort lock: skip update if another devmux is updating.
        if command -v flock >/dev/null 2>&1; then
            if ! { exec 9>"$state_dir/update.lock"; } 2>/dev/null; then
                local tmp_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
                mkdir -p "$tmp_dir" 2>/dev/null || break
                state_dir="$tmp_dir"
                { exec 9>"$state_dir/update.lock"; } 2>/dev/null || break
            fi
            if ! flock -n 9; then
                exec 9>&- 2>/dev/null || true
                break
            fi
            lock_fd_open=true
        else
            lock_dir_path="$state_dir/update.lock.d"
            if ! mkdir "$lock_dir_path" 2>/dev/null; then
                if [[ -d "$lock_dir_path" ]]; then
                    break
                fi
                local tmp_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
                mkdir -p "$tmp_dir" 2>/dev/null || break
                state_dir="$tmp_dir"
                lock_dir_path="$state_dir/update.lock.d"
                mkdir "$lock_dir_path" 2>/dev/null || break
            fi
        fi

        # Optional interval between update attempts (0 = every run).
        local interval="${DEVMUX_UPDATE_INTERVAL_SECS:-0}"
        if [[ "$interval" =~ ^[0-9]+$ ]] && (( interval > 0 )); then
            local stamp="$state_dir/last_update"

            local now last=0
            now="$(date +%s 2>/dev/null || echo 0)"
            last="$(cat "$stamp" 2>/dev/null || echo 0)"

            if [[ "$now" =~ ^[0-9]+$ && "$last" =~ ^[0-9]+$ ]] && (( now - last < interval )); then
                break
            fi

            printf '%s' "$now" >"$stamp" 2>/dev/null || true
        fi

        old_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null || true)"

        local dirty=false
        if ! git -C "$repo_dir" diff --quiet --ignore-submodules -- 2>/dev/null; then
            dirty=true
        elif ! git -C "$repo_dir" diff --cached --quiet --ignore-submodules -- 2>/dev/null; then
            dirty=true
        elif [[ -n "$(git -C "$repo_dir" ls-files --others --exclude-standard 2>/dev/null)" ]]; then
            dirty=true
        fi

        local stash_mode="${DEVMUX_UPDATE_STASH:-0}"
        if $dirty; then
            case "$stash_mode" in
                1|true|yes|on)
                    local ts msg
                    ts="$(date +%Y%m%d-%H%M%S 2>/dev/null || date)"
                    msg="devmux-auto-stash $ts"
                    GIT_TERMINAL_PROMPT=0 GCM_INTERACTIVE=Never \
                        git -C "$repo_dir" stash push -u -m "$msg" >/dev/null 2>&1 || true
                    ;;
                *)
                    break
                    ;;
            esac
        fi

        local ssh_cmd="${GIT_SSH_COMMAND:-ssh -o BatchMode=yes -o ConnectTimeout=5}"
        if GIT_TERMINAL_PROMPT=0 GCM_INTERACTIVE=Never GIT_SSH_COMMAND="$ssh_cmd" \
            git -C "$repo_dir" pull --ff-only >/dev/null 2>&1; then
            updated=true
        fi

        new_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null || true)"
        break
    done

    if $lock_fd_open; then
        exec 9>&- 2>/dev/null || true
    fi
    if [[ -n "$lock_dir_path" ]]; then
        rmdir "$lock_dir_path" 2>/dev/null || true
    fi

    if $updated && [[ -n "$old_head" && -n "$new_head" && "$old_head" != "$new_head" ]]; then
        echo "devmux-remote: updated, restarting..." >&2
        export DEVMUX_REMOTE_SELF_UPDATED=1
        exec "$script_path" "${argv[@]}"
    fi

    return 0
}

_devmux_remote_self_update "$REPO_DIR" "$SCRIPT_PATH" "$@"

# ── Defaults ───────────────────────────────────────────────────────
PROJECT=""
SESSION_ARG=""

# ── Usage ──────────────────────────────────────────────────────────
usage() {
    cat <<'EOF'
Usage: devmux-remote --project <name> [--session <name|new>]

Options:
  --project <name>       Project folder name under ~/projects
  --session <name|new>   Attach to a session by name, or "new" to create one
  --list-projects        List project folders and exit
  --list-sessions        List sessions for a project (requires --project)
  -h, --help             Show this help
EOF
}

# ── Parse args ─────────────────────────────────────────────────────
LIST_SESSIONS=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        --project)  PROJECT="$2"; shift 2 ;;
        --session)  SESSION_ARG="$2"; shift 2 ;;
        --list-sessions) LIST_SESSIONS=true; shift ;;
        --list-projects)
            # Find projects dir and list
            if [[ -d "$HOME/projects" ]]; then
                ls -1 "$HOME/projects" 2>/dev/null || true
            elif [[ -d "$HOME/project" ]]; then
                ls -1 "$HOME/project" 2>/dev/null || true
            fi
            exit 0
            ;;
        -h|--help)  usage; exit 0 ;;
        *)          echo "Unknown option: $1" >&2; usage >&2; exit 1 ;;
    esac
done

# ── Validate ───────────────────────────────────────────────────────
if [[ -z "$PROJECT" ]]; then
    echo "Error: --project is required." >&2
    usage >&2
    exit 1
fi

# ── Validate and sanitize PROJECT name ─────────────────────────────
if [[ "$PROJECT" =~ [[:cntrl:]] ]]; then
    echo "Error: PROJECT name cannot contain control characters or newlines." >&2
    exit 1
fi

if [[ "$PROJECT" =~ [[:space:]] ]]; then
    echo "Warning: Spaces in PROJECT name will be converted to dashes." >&2
    PROJECT="${PROJECT//[[:space:]]/-}"
fi

# ── Resolve project directory ──────────────────────────────────────
PROJECT_DIR=""
if [[ -d "$HOME/projects/$PROJECT" ]]; then
    PROJECT_DIR="$HOME/projects/$PROJECT"
elif [[ -d "$HOME/project/$PROJECT" ]]; then
    PROJECT_DIR="$HOME/project/$PROJECT"
else
    echo "Error: Project '$PROJECT' not found" >&2
    echo "  Searched in:" >&2
    echo "    - $HOME/projects/$PROJECT" >&2
    echo "    - $HOME/project/$PROJECT" >&2
    echo "  To create it:" >&2
    echo "    mkdir -p ~/projects/$PROJECT && cd ~/projects/$PROJECT" >&2
    exit 1
fi

# Sanitize project name for tmux (replace dots with dashes; colons are used as delimiter)
SAFE_PROJECT="${PROJECT//\./-}"

# ── Ensure tmux is available ──────────────────────────────────────
if ! command -v tmux &>/dev/null; then
    echo "Error: tmux is not installed on this host." >&2
    echo "  Install it with your package manager:" >&2
    echo "    Ubuntu/Debian: sudo apt install tmux" >&2
    echo "    Arch: sudo pacman -S tmux" >&2
    echo "    macOS: brew install tmux" >&2
    echo "  Or run devmux settings -> 'Setup remote host' to auto-install" >&2
    exit 1
fi

# ── Session helpers ───────────────────────────────────────────────

# List all tmux sessions belonging to this project.
# Matches 3 formats:
#   - project:N        (new format)
#   - tool:project     (legacy)
#   - tool:project:ts  (legacy with timestamp)
# Output: one line per session — "name|created|activity"
list_project_sessions() {
    local project="$1"
    local raw
    raw=$(tmux list-sessions -F "#{session_name}|#{session_created}|#{session_activity}" 2>/dev/null) || return 0

    local line name
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        name="${line%%|*}"
        # New format: project:N
        if [[ "$name" =~ ^${project}:[0-9]+$ ]]; then
            echo "$line"
            continue
        fi
        # Legacy format: tool:project  (exactly two parts)
        if [[ "$name" =~ ^[^:]+:${project}$ ]]; then
            echo "$line"
            continue
        fi
        # Legacy format: tool:project:timestamp
        if [[ "$name" =~ ^[^:]+:${project}:[0-9]+$ ]]; then
            echo "$line"
            continue
        fi
    done <<< "$raw"
}

# Find the next session number for this project (max existing N + 1).
next_session_number() {
    local project="$1"
    local max=0
    local sessions
    sessions=$(list_project_sessions "$project")

    local line name num
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        name="${line%%|*}"
        if [[ "$name" =~ ^${project}:([0-9]+)$ ]]; then
            num="${BASH_REMATCH[1]}"
            if (( num > max )); then
                max=$num
            fi
        fi
    done <<< "$sessions"

    echo $(( max + 1 ))
}

# Format a timestamp (epoch) as a human-readable relative or absolute time.
format_time() {
    local epoch="$1"
    local now
    now=$(date +%s 2>/dev/null || echo 0)
    local diff=$(( now - epoch ))

    if (( diff < 60 )); then
        echo "just now"
    elif (( diff < 3600 )); then
        echo "$(( diff / 60 ))m ago"
    elif (( diff < 86400 )); then
        echo "$(( diff / 3600 ))h ago"
    elif (( diff < 604800 )); then
        echo "$(( diff / 86400 ))d ago"
    else
        date -d "@$epoch" "+%Y-%m-%d" 2>/dev/null || date -r "$epoch" "+%Y-%m-%d" 2>/dev/null || echo "$epoch"
    fi
}

# ── Handle --list-sessions ────────────────────────────────────────
if $LIST_SESSIONS; then
    list_project_sessions "$SAFE_PROJECT"
    exit 0
fi

debug "Project: $PROJECT"
debug "Project Dir: $PROJECT_DIR"
debug "Session Arg: ${SESSION_ARG:-'(none)'}"

# ── Session selection ─────────────────────────────────────────────
SESSION=""

if [[ -n "$SESSION_ARG" ]]; then
    # Direct session selection via CLI arg
    if [[ "$SESSION_ARG" == "new" ]]; then
        NEXT_NUM=$(next_session_number "$SAFE_PROJECT")
        SESSION="${SAFE_PROJECT}:${NEXT_NUM}"
        debug "Creating new session: $SESSION"
        exec tmux new-session -s "$SESSION" -c "$PROJECT_DIR"
    else
        # Attach to named session
        SESSION="$SESSION_ARG"
        debug "Attaching to session: $SESSION"
        if tmux has-session -t "=$SESSION" 2>/dev/null; then
            exec tmux attach-session -t "=$SESSION"
        else
            echo "Error: Session '$SESSION' not found." >&2
            exit 1
        fi
    fi
fi

# ── Interactive session picker ────────────────────────────────────
SESSION_DATA=$(list_project_sessions "$SAFE_PROJECT")

# Build picker items
PICKER_ITEMS=()
SESSION_NAMES=()

# Always offer "new session" first
PICKER_ITEMS+=("+ New session")
SESSION_NAMES+=("__new__")

# Add existing sessions with formatted info
while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    IFS='|' read -r name created activity <<< "$line"
    created_fmt=$(format_time "$created")
    activity_fmt=$(format_time "$activity")
    PICKER_ITEMS+=("$name  (created $created_fmt, active $activity_fmt)")
    SESSION_NAMES+=("$name")
done <<< "$SESSION_DATA"

if [[ ${#PICKER_ITEMS[@]} -eq 1 ]]; then
    # No existing sessions — create one directly
    NEXT_NUM=$(next_session_number "$SAFE_PROJECT")
    SESSION="${SAFE_PROJECT}:${NEXT_NUM}"
    debug "No existing sessions, creating: $SESSION"
    exec tmux new-session -s "$SESSION" -c "$PROJECT_DIR"
fi

# Show the picker
CHOICE=$(pick "Session:" "${PICKER_ITEMS[@]}") || exit 0

# Find which session was picked
PICKED_SESSION=""
for i in "${!PICKER_ITEMS[@]}"; do
    if [[ "${PICKER_ITEMS[$i]}" == "$CHOICE" ]]; then
        PICKED_SESSION="${SESSION_NAMES[$i]}"
        break
    fi
done

if [[ -z "$PICKED_SESSION" ]]; then
    echo "Error: No session selected." >&2
    exit 1
fi

if [[ "$PICKED_SESSION" == "__new__" ]]; then
    NEXT_NUM=$(next_session_number "$SAFE_PROJECT")
    SESSION="${SAFE_PROJECT}:${NEXT_NUM}"
    debug "Creating new session: $SESSION"
    exec tmux new-session -s "$SESSION" -c "$PROJECT_DIR"
else
    SESSION="$PICKED_SESSION"
    debug "Attaching to session: $SESSION"
    exec tmux attach-session -t "=$SESSION"
fi
