#!/usr/bin/env bash
# devmux-remote — runs on the host inside WSL/Linux.
# Manages tmux sessions for a given project + tool.
set -euo pipefail

# ── Locate repo (for optional self-update) ──────────────────────────
resolve_path() {
    local path="$1"
    local resolved=""

    if command -v realpath >/dev/null 2>&1; then
        resolved=$(realpath "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    if command -v readlink >/dev/null 2>&1; then
        resolved=$(readlink -f "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    local target="$path"
    if command -v readlink >/dev/null 2>&1; then
        while [[ -L "$target" ]]; do
            local link
            link=$(readlink "$target")
            if [[ "$link" = /* ]]; then
                target="$link"
            else
                local dir
                dir=$(cd "$(dirname "$target")" && pwd -P)
                target="$dir/$link"
            fi
        done
    fi

    local dir
    dir=$(cd "$(dirname "$target")" && pwd -P)
    echo "$dir/$(basename "$target")"
}

SCRIPT_PATH="$(resolve_path "$0")"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd -P)"

# ── Optional self-update (git pull) ───────────────────────────────
_devmux_remote_self_update() {
    local repo_dir="$1"
    local script_path="$2"
    shift 2
    local -a argv=("$@")

    local updated=false
    local old_head="" new_head=""

    # Used if flock(1) is available (preferred).
    local lock_fd_open=false

    # Used if flock(1) is NOT available (mkdir-based lock).
    local lock_dir_path=""
    local state_dir=""

    while true; do
        # Only attempt once per process to avoid update loops.
        if [[ -n "${DEVMUX_REMOTE_SELF_UPDATED:-}" ]]; then
            break
        fi

        local auto="${DEVMUX_REMOTE_AUTO_UPDATE:-${DEVMUX_AUTO_UPDATE:-1}}"
        case "$auto" in
            0|false|no|off) break ;;
        esac

        command -v git >/dev/null 2>&1 || break
        git -C "$repo_dir" rev-parse --git-dir >/dev/null 2>&1 || break

        # Cache/lock dir: prefer XDG cache; fall back to /tmp if not writable.
        local try_dir=""
        try_dir="${XDG_CACHE_HOME:-$HOME/.cache}/devmux"
        if mkdir -p "$try_dir" 2>/dev/null; then
            state_dir="$try_dir"
        else
            try_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
            mkdir -p "$try_dir" 2>/dev/null || break
            state_dir="$try_dir"
        fi

        # Best-effort lock: skip update if another devmux is updating.
        if command -v flock >/dev/null 2>&1; then
            if ! { exec 9>"$state_dir/update.lock"; } 2>/dev/null; then
                local tmp_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
                mkdir -p "$tmp_dir" 2>/dev/null || break
                state_dir="$tmp_dir"
                { exec 9>"$state_dir/update.lock"; } 2>/dev/null || break
            fi
            if ! flock -n 9; then
                exec 9>&- 2>/dev/null || true
                break
            fi
            lock_fd_open=true
        else
            lock_dir_path="$state_dir/update.lock.d"
            if ! mkdir "$lock_dir_path" 2>/dev/null; then
                if [[ -d "$lock_dir_path" ]]; then
                    break
                fi
                local tmp_dir="${TMPDIR:-/tmp}/devmux-${UID:-0}"
                mkdir -p "$tmp_dir" 2>/dev/null || break
                state_dir="$tmp_dir"
                lock_dir_path="$state_dir/update.lock.d"
                mkdir "$lock_dir_path" 2>/dev/null || break
            fi
        fi

        # Optional interval between update attempts (0 = every run).
        local interval="${DEVMUX_UPDATE_INTERVAL_SECS:-0}"
        if [[ "$interval" =~ ^[0-9]+$ ]] && (( interval > 0 )); then
            local stamp="$state_dir/last_update"

            local now last=0
            now="$(date +%s 2>/dev/null || echo 0)"
            last="$(cat "$stamp" 2>/dev/null || echo 0)"

            if [[ "$now" =~ ^[0-9]+$ && "$last" =~ ^[0-9]+$ ]] && (( now - last < interval )); then
                break
            fi

            printf '%s' "$now" >"$stamp" 2>/dev/null || true
        fi

        old_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null || true)"

        local dirty=false
        if ! git -C "$repo_dir" diff --quiet --ignore-submodules -- 2>/dev/null; then
            dirty=true
        elif ! git -C "$repo_dir" diff --cached --quiet --ignore-submodules -- 2>/dev/null; then
            dirty=true
        elif [[ -n "$(git -C "$repo_dir" ls-files --others --exclude-standard 2>/dev/null)" ]]; then
            dirty=true
        fi

        local stash_mode="${DEVMUX_UPDATE_STASH:-0}"
        if $dirty; then
            case "$stash_mode" in
                1|true|yes|on)
                    local ts msg
                    ts="$(date +%Y%m%d-%H%M%S 2>/dev/null || date)"
                    msg="devmux-auto-stash $ts"
                    GIT_TERMINAL_PROMPT=0 GCM_INTERACTIVE=Never \
                        git -C "$repo_dir" stash push -u -m "$msg" >/dev/null 2>&1 || true
                    ;;
                *)
                    break
                    ;;
            esac
        fi

        local ssh_cmd="${GIT_SSH_COMMAND:-ssh -o BatchMode=yes -o ConnectTimeout=5}"
        if GIT_TERMINAL_PROMPT=0 GCM_INTERACTIVE=Never GIT_SSH_COMMAND="$ssh_cmd" \
            git -C "$repo_dir" pull --ff-only >/dev/null 2>&1; then
            updated=true
        fi

        new_head="$(git -C "$repo_dir" rev-parse HEAD 2>/dev/null || true)"
        break
    done

    if $lock_fd_open; then
        exec 9>&- 2>/dev/null || true
    fi
    if [[ -n "$lock_dir_path" ]]; then
        rmdir "$lock_dir_path" 2>/dev/null || true
    fi

    if $updated && [[ -n "$old_head" && -n "$new_head" && "$old_head" != "$new_head" ]]; then
        echo "devmux-remote: updated, restarting..." >&2
        export DEVMUX_REMOTE_SELF_UPDATED=1
        exec "$script_path" "${argv[@]}"
    fi

    return 0
}

_devmux_remote_self_update "$REPO_DIR" "$SCRIPT_PATH" "$@"

# ── Defaults ───────────────────────────────────────────────────────
PROJECT=""
TOOL=""
TOOL_CMD=""
MODE="resume"

# ── Usage ──────────────────────────────────────────────────────────
usage() {
    cat <<'EOF'
Usage: devmux-remote --project <name> --tool <name> [--tool-cmd <cmd>] --mode <resume|new>

Options:
  --project <name>    Project folder name under ~/projects
  --tool <name>       Tool nickname (used in session name)
  --tool-cmd <cmd>    Command to run inside tmux (empty = bash)
  --mode <resume|new> resume: attach existing or create; new: always create
  --list-projects     List project folders and exit
  -h, --help          Show this help
EOF
}

# ── Parse args ─────────────────────────────────────────────────────
while [[ $# -gt 0 ]]; do
    case "$1" in
        --project)  PROJECT="$2"; shift 2 ;;
        --tool)     TOOL="$2"; shift 2 ;;
        --tool-cmd) TOOL_CMD="$2"; shift 2 ;;
        --mode)     MODE="$2"; shift 2 ;;
        --list-projects)
            # Find projects dir and list
            if [[ -d "$HOME/projects" ]]; then
                ls -1 "$HOME/projects" 2>/dev/null || true
            elif [[ -d "$HOME/project" ]]; then
                ls -1 "$HOME/project" 2>/dev/null || true
            fi
            exit 0
            ;;
        -h|--help)  usage; exit 0 ;;
        *)          echo "Unknown option: $1" >&2; usage >&2; exit 1 ;;
    esac
done

# ── Validate ───────────────────────────────────────────────────────
if [[ -z "$PROJECT" || -z "$TOOL" ]]; then
    echo "Error: --project and --tool are required." >&2
    usage >&2
    exit 1
fi

if [[ "$MODE" != "resume" && "$MODE" != "new" ]]; then
    echo "Error: --mode must be 'resume' or 'new'." >&2
    exit 1
fi

# ── Resolve project directory ──────────────────────────────────────
PROJECT_DIR=""
if [[ -d "$HOME/projects/$PROJECT" ]]; then
    PROJECT_DIR="$HOME/projects/$PROJECT"
elif [[ -d "$HOME/project/$PROJECT" ]]; then
    PROJECT_DIR="$HOME/project/$PROJECT"
else
    echo "Error: project '$PROJECT' not found in ~/projects or ~/project." >&2
    exit 1
fi

# ── Session name ───────────────────────────────────────────────────
# Sanitize for tmux (replace dots/colons with dashes)
SAFE_PROJECT="${PROJECT//[.:]/-}"
SAFE_TOOL="${TOOL//[.:]/-}"

if [[ "$MODE" == "resume" ]]; then
    SESSION_BASE_PRIMARY="${SAFE_TOOL}:${SAFE_PROJECT}"
    SESSION_BASE_LEGACY="${SAFE_TOOL}_${SAFE_PROJECT}"
    SESSION="$SESSION_BASE_PRIMARY"
else
    SESSION_BASE_PRIMARY="${SAFE_TOOL}:${SAFE_PROJECT}"
    SESSION_BASE_LEGACY=""
    SESSION="${SESSION_BASE_PRIMARY}:$(date +%s)"
fi

# ── Build tmux command ─────────────────────────────────────────────
if [[ -n "$TOOL_CMD" ]]; then
    SHELL_CMD="bash -lc '${TOOL_CMD//\'/\'\\\'\'}; exec bash -l'"
else
    SHELL_CMD=""
fi

# Ensure tmux is available
if ! command -v tmux &>/dev/null; then
    echo "Error: tmux is not installed on this host." >&2
    exit 1
fi

# Backward-compat: older devmux versions used <tool>_<project> for sessions.
# If the new name doesn't exist but the legacy one does, attach the legacy.
if [[ "$MODE" == "resume" && -n "${SESSION_BASE_LEGACY:-}" ]]; then
    if tmux has-session -t "=$SESSION_BASE_PRIMARY" 2>/dev/null; then
        SESSION="$SESSION_BASE_PRIMARY"
    elif tmux has-session -t "=$SESSION_BASE_LEGACY" 2>/dev/null; then
        SESSION="$SESSION_BASE_LEGACY"
    fi
fi

if [[ -n "$SHELL_CMD" ]]; then
    if [[ "$MODE" == "resume" ]]; then
        # -A: attach if it exists, otherwise create (avoids "duplicate session" races)
        exec tmux new-session -A -s "$SESSION" -c "$PROJECT_DIR" "$SHELL_CMD"
    fi
    exec tmux new-session -s "$SESSION" -c "$PROJECT_DIR" "$SHELL_CMD"
fi

if [[ "$MODE" == "resume" ]]; then
    exec tmux new-session -A -s "$SESSION" -c "$PROJECT_DIR"
fi
exec tmux new-session -s "$SESSION" -c "$PROJECT_DIR"
