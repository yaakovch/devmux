#!/usr/bin/env bash
# setup.sh — bootstrap devmux on Linux/WSL/Termux.
# Clone the repo, run this script, and you're set up.
set -euo pipefail

# ── Locate repo root ─────────────────────────────────────────────
resolve_path() {
    local path="$1"
    local resolved=""

    if command -v realpath >/dev/null 2>&1; then
        resolved=$(realpath "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    if command -v readlink >/dev/null 2>&1; then
        resolved=$(readlink -f "$path" 2>/dev/null || true)
        if [[ -n "$resolved" ]]; then
            echo "$resolved"
            return 0
        fi
    fi

    local target="$path"
    if command -v readlink >/dev/null 2>&1; then
        while [[ -L "$target" ]]; do
            local link
            link=$(readlink "$target")
            if [[ "$link" = /* ]]; then
                target="$link"
            else
                local dir
                dir=$(cd "$(dirname "$target")" && pwd -P)
                target="$dir/$link"
            fi
        done
    fi

    local dir
    dir=$(cd "$(dirname "$target")" && pwd -P)
    echo "$dir/$(basename "$target")"
}

choose_bin_dir() {
    local platform="$1"
    local default_dir="$HOME/.local/bin"

    if [[ "$platform" == "termux" && -n "${PREFIX:-}" && -d "$PREFIX/bin" && -w "$PREFIX/bin" ]]; then
        echo "$PREFIX/bin"
        return 0
    fi

    if [[ ":$PATH:" == *":$default_dir:"* ]]; then
        echo "$default_dir"
        return 0
    fi

    local path_dir
    local -a path_dirs
    IFS=: read -r -a path_dirs <<< "$PATH"
    for path_dir in "${path_dirs[@]}"; do
        [[ -z "$path_dir" || "$path_dir" == "." ]] && continue
        if [[ -d "$path_dir" && -w "$path_dir" ]]; then
            echo "$path_dir"
            return 0
        fi
    done

    echo "$default_dir"
}

SCRIPT_PATH="$(resolve_path "$0")"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd -P)"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/devmux"

# Source libraries
source "$REPO_DIR/lib/common.sh"
source "$REPO_DIR/lib/platform.sh"
source "$REPO_DIR/lib/tailscale.sh"
source "$REPO_DIR/lib/ssh.sh"

# Source machine definitions
source "$REPO_DIR/machines.conf"

# ── Helper: generate devmux.conf from machines.conf ──────────────
_generate_devmux_conf() {
    local hosts=()
    local host_lines=""
    local is_host="${IS_HOST:-false}"

    local machine m_prefix m_os_var m_os distro_var distro
    for machine in "${MACHINES[@]}"; do
        if [[ "$machine" == "$THIS_MACHINE" ]]; then
            # If this machine is also a host, include a self-entry that runs locally.
            # This avoids SSH-to-self loops and lets you use the same menu locally.
            if [[ "$is_host" == "true" ]]; then
                hosts+=("$machine")
                host_lines+="HOST_${machine//-/_}_SSH=\"local\"\n"
                host_lines+="HOST_${machine//-/_}_WSL_PREFIX=\"\"\n"
                host_lines+="\n"
            fi
            continue
        fi

        m_prefix="MACHINE_${machine//-/_}"
        m_os_var="${m_prefix}_OS"
        m_os="${!m_os_var:-linux}"

        # Use machine name as host nickname
        hosts+=("$machine")

        host_lines+="HOST_${machine//-/_}_SSH=\"${machine}\"\n"

        if [[ "$m_os" == "windows-wsl" ]]; then
            distro_var="${m_prefix}_WSL_DISTRO"
            distro="${!distro_var:-Ubuntu}"
            host_lines+="HOST_${machine//-/_}_WSL_PREFIX=\"wsl -d ${distro} --exec bash -lc\"\n"
        else
            host_lines+="HOST_${machine//-/_}_WSL_PREFIX=\"\"\n"
        fi
        host_lines+="\n"
    done

    cat <<EOF
# devmux configuration — generated by setup.sh
# Edit freely; re-running setup.sh will not overwrite this file.

# ── Hosts ──────────────────────────────────────────────────────────
HOSTS=($(printf '"%s" ' "${hosts[@]}"))

$(echo -e "$host_lines")
# ── Tools ──────────────────────────────────────────────────────────
TOOLS=("codex" "claude" "shell")
TOOL_codex_CMD="codex"
TOOL_claude_CMD="claude"
TOOL_shell_CMD=""
EOF
}

# ── Step 0: Optional gum install ─────────────────────────────────
if ! command -v gum &>/dev/null; then
    info ""
    info "  gum not found (optional — makes menus prettier)"
    if confirm "  Install gum?"; then
        if command -v apt-get &>/dev/null; then
            sudo mkdir -p /etc/apt/keyrings
            curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg
            echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | sudo tee /etc/apt/sources.list.d/charm.list
            sudo apt-get update -qq && sudo apt-get install -y -qq gum
        elif command -v pacman &>/dev/null; then
            sudo pacman -Sy --noconfirm gum
        elif command -v pkg &>/dev/null; then
            pkg install -y gum
        elif command -v brew &>/dev/null; then
            brew install gum
        else
            info "  Could not detect package manager. Install gum manually:"
            info "  https://github.com/charmbracelet/gum#installation"
        fi
    fi
fi

# ── Step 1: Detect platform ──────────────────────────────────────
PLATFORM=$(detect_platform)
HOSTNAME_SHORT=$(detect_hostname)
BIN_DIR="$(choose_bin_dir "$PLATFORM")"
header "devmux setup"
info "  Platform: $PLATFORM"
info "  Hostname: $HOSTNAME_SHORT"
info ""

# ── Step 2: Identify this machine ────────────────────────────────
THIS_MACHINE=""

# Try auto-detect via Tailscale IP
if tailscale_available; then
    THIS_MACHINE=$(tailscale_identify_self) || true
    if [[ -n "$THIS_MACHINE" ]]; then
        info "  Auto-detected machine: $THIS_MACHINE (via Tailscale IP)"
    fi
fi

# Try auto-detect via hostname
if [[ -z "$THIS_MACHINE" ]]; then
    for machine in "${MACHINES[@]}"; do
        if [[ "$HOSTNAME_SHORT" == "$machine" ]]; then
            THIS_MACHINE="$machine"
            info "  Auto-detected machine: $THIS_MACHINE (via hostname)"
            break
        fi
    done
fi

# Ask if not detected
if [[ -z "$THIS_MACHINE" ]]; then
    info "  Could not auto-detect this machine."
    info "  Known machines: ${MACHINES[*]}"
    THIS_MACHINE=$(pick "Which machine is this?" "${MACHINES[@]}" "new-machine")

    if [[ "$THIS_MACHINE" == "new-machine" ]]; then
        read -rp "Enter a name for this machine (lowercase, hyphens ok): " THIS_MACHINE
        info ""
        info "  To add this machine permanently, edit machines.conf and add:"
        info "    MACHINE_${THIS_MACHINE//-/_}_TAILSCALE_IP=\"<ip>\""
        info "    MACHINE_${THIS_MACHINE//-/_}_OS=\"$PLATFORM\""
        info ""
    fi
fi

# ── Step 3: Determine role ────────────────────────────────────────
var_prefix="MACHINE_${THIS_MACHINE//-/_}"
ROLES=()
if declare -p "${var_prefix}_ROLES" &>/dev/null 2>&1; then
    eval "ROLES=(\"\${${var_prefix}_ROLES[@]}\")"
fi

if [[ ${#ROLES[@]} -eq 0 ]]; then
    ROLE=$(pick "What role for this machine?" "host" "client" "both")
else
    # Flatten roles
    if [[ " ${ROLES[*]} " == *" both "* ]]; then
        ROLE="both"
    elif [[ ${#ROLES[@]} -eq 1 ]]; then
        ROLE="${ROLES[0]}"
    else
        ROLE="both"
    fi
    info "  Role: $ROLE (from machines.conf)"
fi

IS_HOST=false
IS_CLIENT=false
case "$ROLE" in
    host)   IS_HOST=true ;;
    client) IS_CLIENT=true ;;
    both)   IS_HOST=true; IS_CLIENT=true ;;
esac

# ── Step 4: Host setup ───────────────────────────────────────────
if $IS_HOST; then
    info ""
    header "Host setup"

    # Ensure tmux
    if ! command -v tmux &>/dev/null; then
        info "  tmux not found. Installing..."
        if command -v apt-get &>/dev/null; then
            sudo apt-get update -qq && sudo apt-get install -y -qq tmux
        elif command -v pacman &>/dev/null; then
            sudo pacman -Sy --noconfirm tmux
        elif command -v pkg &>/dev/null; then
            pkg install -y tmux
        elif command -v brew &>/dev/null; then
            brew install tmux
        else
            die "Cannot install tmux automatically. Install it manually."
        fi
    fi
    info "  tmux: $(tmux -V)"

    # Symlink devmux-remote
    mkdir -p "$BIN_DIR"
    ln -sf "$REPO_DIR/scripts/devmux-remote" "$BIN_DIR/devmux-remote"
    info "  Symlinked: devmux-remote → $BIN_DIR/devmux-remote"

    # Ensure ~/projects
    mkdir -p "$HOME/projects"
    info "  Ensured ~/projects/ exists"
fi

# ── Step 5: Client setup ─────────────────────────────────────────
if $IS_CLIENT; then
    info ""
    header "Client setup"

    # Symlink devmux
    mkdir -p "$BIN_DIR"
    ln -sf "$REPO_DIR/scripts/devmux" "$BIN_DIR/devmux"
    info "  Symlinked: devmux → $BIN_DIR/devmux"

    # Termux shortcut
    if [[ "$PLATFORM" == "termux" ]]; then
        mkdir -p "$HOME/.shortcuts"
        ln -sf "$REPO_DIR/termux/shortcuts/devmux" "$HOME/.shortcuts/devmux"
        info "  Symlinked: Termux shortcut → ~/.shortcuts/devmux"
    fi

    # Generate devmux.conf if missing
    mkdir -p "$CONFIG_DIR"
    if [[ ! -f "$CONFIG_DIR/devmux.conf" ]]; then
        info "  Generating devmux.conf from machines.conf..."
        _generate_devmux_conf > "$CONFIG_DIR/devmux.conf"
        info "  Created: $CONFIG_DIR/devmux.conf"
    else
        info "  Config exists: $CONFIG_DIR/devmux.conf (skipped)"
        info "  To regenerate: rm $CONFIG_DIR/devmux.conf && re-run setup.sh"
    fi

    # Generate SSH config
    info "  Generating SSH config entries..."
    ssh_config_content=$(generate_ssh_config)
    if [[ -n "$ssh_config_content" ]]; then
        write_ssh_config "$ssh_config_content"
        info "  Updated ~/.ssh/config (devmux-managed block)"
    fi
fi

# ── Step 6: SSH key setup ────────────────────────────────────────
info ""
header "SSH keys"

ensure_ssh_key

PUB_KEY_PATH="$HOME/.ssh/id_${SSH_KEY_TYPE}.pub"
if [[ -f "$PUB_KEY_PATH" ]]; then
    PUB_KEY_CONTENT=$(<"$PUB_KEY_PATH")
    info ""
    info "  Your public key:"
    info "  $PUB_KEY_CONTENT"

    if $IS_CLIENT; then
        info ""
        header "Key distribution"
        for machine in "${MACHINES[@]}"; do
            [[ "$machine" == "$THIS_MACHINE" ]] && continue

            m_prefix="MACHINE_${machine//-/_}"
            m_os_var="${m_prefix}_OS"
            m_os="${!m_os_var:-linux}"
            m_ts_ip_var="${m_prefix}_TAILSCALE_IP"
            m_ts_ip="${!m_ts_ip_var:-}"
            m_win_user_var="${m_prefix}_WIN_USER"
            m_win_user="${!m_win_user_var:-}"

            [[ -z "$m_ts_ip" ]] && continue

            info ""
            info "  Machine: $machine ($m_ts_ip)"

            if [[ "$m_os" == "windows-wsl" ]]; then
                # Windows host — need to deploy to admin authorized_keys
                info "  This is a Windows host. Key must go to administrators_authorized_keys."

                # Try SSH if it already works
                if ssh -o ConnectTimeout=5 -o BatchMode=yes "${m_win_user}@${m_ts_ip}" "echo ok" &>/dev/null 2>&1; then
                    if confirm "  SSH works to $machine. Deploy key automatically?"; then
                        if deploy_key_windows_ssh "${m_win_user}@${m_ts_ip}" "$PUB_KEY_PATH"; then
                            info "  Key deployed to $machine."
                        else
                            info "  Automatic key deployment failed."
                            info "  Run these commands on that Windows machine:"
                            deploy_key_windows_commands "$PUB_KEY_CONTENT" "$m_win_user"
                        fi
                    fi
                else
                    info "  SSH not yet working to $machine. Run these commands on that Windows machine:"
                    deploy_key_windows_commands "$PUB_KEY_CONTENT" "$m_win_user"
                fi
            else
                # Linux host — try ssh-copy-id
                target_user_var="${m_prefix}_WSL_USER"
                target_user="${!target_user_var:-}"
                target="${target_user:+${target_user}@}${m_ts_ip}"

                if ssh -o ConnectTimeout=5 -o BatchMode=yes "$target" "echo ok" &>/dev/null 2>&1; then
                    if confirm "  SSH works to $machine. Deploy key?"; then
                        deploy_key_linux "$target" "$PUB_KEY_PATH"
                        info "  Key deployed to $machine."
                    fi
                else
                    info "  SSH not yet working to $machine."
                    info "  Copy your public key manually:"
                    info "    ssh-copy-id $target"
                fi
            fi
        done
    fi
fi

# ── Step 7: PATH check ───────────────────────────────────────────
if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
    info ""
    info "  NOTE: $BIN_DIR is not in your PATH."
    info "  Add this to your shell profile (~/.bashrc or ~/.zshrc):"
    info "    export PATH=\"${BIN_DIR}:\$PATH\""
fi

info ""
header "Setup complete"
if $IS_CLIENT; then
    info "  Run 'devmux' to launch."
fi
if $IS_HOST; then
    info "  This machine is ready to receive devmux connections."
fi
